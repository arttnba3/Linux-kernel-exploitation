# CVE-2021-22555

> You can visit [my blog](https://arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/) for Chinese version.

CVE-2021-22555 is a heap out-of-bounds write vulnerability in `net/netfilter/x_tables.c`, affecting Linux kernel since `v2.6.19-rc1`.

The vulnerability appears in 32-bit's compact syscall `setsockopt()`, which will finally call the `xt_compat_match_from_user()` and `xt_compat_target_from_user()`. Both of them are with the same vulnerability.

We take the `xt_compat_match_from_user()` as an example here. In this function the kernel will set the values to zero on the area from `t->data[target->targetsize]` with a length of `pad`.

```c
void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
				unsigned int *size)
{
	const struct xt_target *target = t->u.kernel.target;
	struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
	int pad, off = xt_compat_target_offset(target);
	u_int16_t tsize = ct->u.user.target_size;
	char name[sizeof(t->u.user.name)];

	t = *dstptr;
	memcpy(t, ct, sizeof(*ct));
	if (target->compat_from_user)
		target->compat_from_user(t->data, ct->data);
	else
		memcpy(t->data, ct->data, tsize - sizeof(*ct));
	pad = XT_ALIGN(target->targetsize) - target->targetsize;
	if (pad > 0)
		memset(t->data + target->targetsize, 0, pad);	// vulnerability

	tsize += off;
	t->u.user.target_size = tsize;
	strlcpy(name, target->name, sizeof(name));
	module_put(target->me);
	strncpy(t->u.user.name, name, sizeof(t->u.user.name));

	*size += off;
	*dstptr += tsize;
}
EXPORT_SYMBOL_GPL(xt_compat_target_from_user);
```

As the address of `target->data` is aligned to 64bit, we'll have such an ideal case here like this (suppose the `target->targetsize` is less than 8 here):

![ideal case](https://s2.loli.net/2022/03/31/3jlPfpg2AMYoZrv.png)

But the `target->data` in fact is possible to be not aligned to 8 bytes **while we still trying to align the `target->targetsize` to the times of `8`, which finally cause a potential heap out-of-bounds write here:**

![vulnerability case](https://s2.loli.net/2022/03/31/eS15WvRZuz8f6HU.png)

The code of exploitation is in `exp.c`, which abuse the heap out-of-bounds to overwrite the header of a `msg_msg` structure, making two `msg_msg` points to the same `msg_msg` on the `msg_queue` so that a UAF can be done.

### REFERENCE

[CVE-2021-22555: Turning \x00\x00 into 10000$](https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html)

[My blog(Chinese)](https://arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/)
