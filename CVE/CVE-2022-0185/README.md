# CVE-2022-0185

### Introduction

[CVE-2022-0185](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0185) is a heap out-of-bound write vulnerability in `fsconfig` syscall in Linux kernel, which allows local attacker who has `CAP_SYS_ADMIN` privilege (or the unprivileged namespace is enabled) to escalate to root by it.

As the legacy `mount` API was thought to be with many gaps in design, the [Filesystem Mount API](https://docs.kernel.org/filesystems/mount_api.html) is developed to be the new one to do the job, which devides the original `mount` into many different syscalls.

For using the new API, we need to firstly call the `fsopen` syscall to create a `filesystem context` corresponding to a `fs_context` structure in kernel. Then we need to use `fsconfig` syscall to configure the context, which will do the operations according to the parameters. The vulnerability appeared in the `FSCONFIG_SET_STRING` operation, which will finally call the `vfs_parse_fs_param()` to copy a string passed from user, making a new string on the buffer in `"key=value,"` format.

```c
int vfs_parse_fs_param(struct fs_context *fc, struct fs_parameter *param)
{
	int ret;

	//...

	if (fc->ops->parse_param) {
		ret = fc->ops->parse_param(fc, param);
		if (ret != -ENOPARAM)
			return ret;
	}
```

For the file system which doesn't have the `init_fs_context` information, the `legacy_fs_context_ops` will be assigned as the `fs_context_operations` of `fs_context`, which means that the `legacy_parse_param()` will be called here. The vulnerability is in the check of length. Considering the situation of `size + 2 > PAGE_SIZE`, as the `size` is an unsigned integer, the result of `PAGE_SIZE - 2 - size` will overflow to a large number, which is surely bigger than `len` and pass the check.

```c
static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)
{
	struct legacy_fs_context *ctx = fc->fs_private;
	unsigned int size = ctx->data_size;
	size_t len = 0;

	//...

	switch (param->type) {
	case fs_value_is_string:
		len = 1 + param->size;
		/* Fall through */
	case fs_value_is_flag:
		len += strlen(param->key);
		break;
	default:
		return invalf(fc, "VFS: Legacy: Parameter type for '%s' not supported",
			      param->key);
	}

	if (len > PAGE_SIZE - 2 - size)
		return invalf(fc, "VFS: Legacy: Cumulative options too large");
```

Note that only one page is allocated to the `legacy_data` buffer, a heap out-of-bound write will surely happen if the copy continue.

```c
	if (!ctx->legacy_data) {
		ctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);
		if (!ctx->legacy_data)
			return -ENOMEM;
	}
```

### Exploitation

The code of exploitation is in `exp.c`, which abuse the heap out-of-bounds to make a partial overwrite on `pipe_buffer->page` to construct a page-level UAF. I use the same technique in [D^ 3CTF2023 - d3kcache](https://blog.arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/), you can refer to my blog for more details :)
