# CVE-2022-0995

> You can visit [my blog](https://arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/) for Chinese version.

CVE-2022-0995 is a heap out-of-bounds write vunerability in _watch queue event notification subsystem_, affecting Linux kernel since `v5.8`.

The [general notification mechanism](https://docs.kernel.org/core-api/watch_queue.html) is established on the standard pipe driver, which collects notification messages from kernel to the pipe that provided by user.

As we call the `ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &filter)`, the `pipe_ioctl()` will be called and it finally flows into `watch_queue_set_filter()`. The function will firstly do the data copy from user space to a temporary kernel object:

```c
long watch_queue_set_filter(struct pipe_inode_info *pipe,
			    struct watch_notification_filter __user *_filter)
{
	struct watch_notification_type_filter *tf;
	struct watch_notification_filter filter;
	struct watch_type_filter *q;
	struct watch_filter *wfilter;
	struct watch_queue *wqueue = pipe->watch_queue;
	int ret, nr_filter = 0, i;

	if (!wqueue)
		return -ENODEV;

	if (!_filter) {
		/* Remove the old filter */
		wfilter = NULL;
		goto set;
	}

	/* Grab the user's filter specification */
	if (copy_from_user(&filter, _filter, sizeof(filter)) != 0)
		return -EFAULT;
	if (filter.nr_filters == 0 ||
	    filter.nr_filters > 16 ||
	    filter.__reserved != 0)
		return -EINVAL;

    tf = memdup_user(_filter->filters, filter.nr_filters * sizeof(*tf));
	if (IS_ERR(tf))
		return PTR_ERR(tf);
```

And every `watch_notification_type_filter` structure will be checked and the number of the one with legal `type` (which should be no more than `sizeof(wfilter->type_filter) * 8` ) will be recorded into `nr_filter`:

```c
	ret = -EINVAL;
	for (i = 0; i < filter.nr_filters; i++) {
		if ((tf[i].info_filter & ~tf[i].info_mask) ||
		    tf[i].info_mask & WATCH_INFO_LENGTH)
			goto err_filter;
		/* Ignore any unknown types */
		if (tf[i].type >= sizeof(wfilter->type_filter) * 8)
			continue;
		nr_filter++;
	}
```

Finally it allocates a new kernel object with size `struct_size(wfilter, filters, nr_filter)` (which is `sizeof(wfilter) + sizeof(filters) * nr_filter` in fact) and starts to do the real copy, **the first vulnerability appears in the process of copying the filter with different method to do the validation check compared to before**. As the `BITS_PER_LONG == 64`, we can set some of the filter to the type in range `[sizeof(wfilter->type_filter) * 8, sizeof(wfilter->type_filter) * 64]`, which will finally lead to a **heap out-of-bounds write**.


```c
	/* Now we need to build the internal filter from only the relevant
	 * user-specified filters.
	 */
	ret = -ENOMEM;
	wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);
	if (!wfilter)
		goto err_filter;
	wfilter->nr_filters = nr_filter;

	q = wfilter->filters;
	for (i = 0; i < filter.nr_filters; i++) {
		if (tf[i].type >= sizeof(wfilter->type_filter) * BITS_PER_LONG)
			continue;

		q->type			= tf[i].type;
		q->info_filter		= tf[i].info_filter;
		q->info_mask		= tf[i].info_mask;
		q->subtype_filter[0]	= tf[i].subtype_filter[0];
		__set_bit(q->type, wfilter->type_filter);
		q++;
	}heap out-of-bounds write
```

**The second vulnerability appears in the call of `__set_bit()`, as the `type` can be in the range of [0x80, 0x400), we can easily do a heap out-of-bounds 1-bit setting like this** (assuming the `kmalloc-96` is the victim):

![](https://s2.loli.net/2022/04/06/KZAFrduvUizs4Dg.png)

The code of exploitation is in `exp.c`, which abuse the second heap out-of-bounds to overwrite the header of a `msg_msg` structure, making two `msg_msg` points to the same `msg_msg` on the `msg_queue` so that a UAF can be done.
